# Цель: понять разницу между линейным и многопроцессным подходом, выполнив операции обоими способами.
# Задача "Многопроцессное считывание":
# Необходимо считать информацию из нескольких файлов одновременно, используя многопроцессный подход.
# Подготовка:
# Скачайте архив с файлами для считывания данных и распакуйте его в проект для дальнейшего использования.

# Вызовите функцию read_info для каждого файла по очереди (линейно) и измерьте время выполнения и выведите его в консоль.
# Вызовите функцию read_info для каждого файла, используя многопроцессный подход: контекстный менеджер with и объект Pool.
# Для вызова функции используйте метод map, передав в него функцию read_info и список названий файлов. Измерьте время выполнения и выведите его в консоль.
# Для избежания некорректного вывода запускайте линейный вызов и многопроцессный по отдельности, предварительно закомментировав другой.
#
# Примечания:
# Используйте конструкцию if __name__ == '__main__' при многопроссном подходе.
# Выводить или возвращать список all_data в функции не нужно. Можете сделать это, но кол-во информации в файлах достигает - 10^9 строк.
# Дополнительно о классе Pool можете прочитать здесь.

import os
import multiprocessing
from multiprocessing import Pool
# import threading
import time


# Создайте функцию read_info(name), где name - название файла. Функция должна:
# Создавать локальный список all_data.
# Открывать файл name для чтения.
# Считывать информацию построчно (readline), пока считанная строка не окажется пустой.
# Во время считывания добавлять каждую строку в список all_data.
# Этих операций достаточно, чтобы рассмотреть преимущество многопроцессного выполнения программы над линейным.
# Создайте список названий файлов в соответствии с названиями файлов архива.
all_data = []
def read_info(name):
    global all_data
    with open(name, 'r', encoding='utf-8') as file:
        while True:
            line = file.readline()
            if not line:  # Если строка пустая, выходим из цикла
                break
            all_data.append(line.strip())
    return all_data

if __name__ == '__main__':
    file_names = ['file 1.txt', 'file 2.txt', 'file 3.txt', 'file 4.txt']

    start_time = time.time()
    for file in file_names:
        all_data.extend(read_info(file))
    linear_time = time.time() - start_time
    print(f'Время линейного прохода: {linear_time} сек')

    start_time = time.time()
    with Pool() as pool:
        results = pool.map(read_info, file_names)
    all_data = [item for sublist in results for item in sublist]
    multiprocessing_time = time.time() - start_time
    print(f'Время многопроцессного считывания: {multiprocessing_time} сек')
